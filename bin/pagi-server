#!/usr/bin/env perl
use strict;
use warnings;
use experimental 'signatures';
use Getopt::Long;
use Pod::Usage;
use IO::Async::Loop;

use lib 'lib';
use PAGI::Server;

=head1 NAME

pagi-server - PAGI Reference Server CLI

=head1 SYNOPSIS

    pagi-server --app app.pl [options]

    Options:
        --app, -a       Path to .pl file returning PAGI app coderef (required)
        --host, -h      Bind address (default: 127.0.0.1)
        --port, -p      Bind port (default: 5000)
        --workers, -w   Number of worker processes (default: 1)
        --loop, -l      Event loop backend (Poll, EV, Epoll, UV)
        --ssl-cert      Path to SSL certificate (enables HTTPS)
        --ssl-key       Path to SSL private key
        --access-log    Path to access log file (default: STDERR)
        --quiet, -q     Suppress startup banner
        --help          Show this help

=head1 EXAMPLES

    # Start with a simple app
    pagi-server --app examples/01-hello-http/app.pl --port 8080

    # Start with HTTPS
    pagi-server -a myapp.pl -p 3000 --ssl-cert cert.pem --ssl-key key.pem

    # Start with multiple workers
    pagi-server -a myapp.pl -p 5000 --workers 4

    # Use a specific event loop backend (for better performance)
    pagi-server -a myapp.pl -p 5000 --workers 4 --loop EV

    # Or via environment variable
    IO_ASYNC_LOOP=Epoll pagi-server -a myapp.pl -p 5000 --workers 4

=head1 ENVIRONMENT

=over 4

=item IO_ASYNC_LOOP

Specifies which IO::Async::Loop backend to use. The default is auto-detection,
which typically selects Poll on most systems. For better performance, especially
with many concurrent connections, install and use one of:

    IO_ASYNC_LOOP=Epoll    # Linux (requires IO::Async::Loop::Epoll)
    IO_ASYNC_LOOP=EV       # Cross-platform (requires IO::Async::Loop::EV)

The --loop command-line option takes precedence over this environment variable.

The chosen loop type is displayed at startup unless --quiet is specified.
In multi-worker mode, all worker processes inherit the same loop type.

=back

=head1 EVENT LOOP BACKENDS

The following event loop backends are supported (requires corresponding module):

=over 4

=item Poll

The default fallback. Uses poll() system call. O(n) complexity per event.
Works everywhere but slower with many connections.

=item EV

High-performance backend using libev. Uses kqueue on macOS/BSD, epoll on Linux.
Recommended for production. Install: C<cpanm IO::Async::Loop::EV EV>

=item Epoll

Linux-specific backend using epoll. O(1) complexity.
Install: C<cpanm IO::Async::Loop::Epoll>

=item UV

Backend using libuv (Node.js's event library). Cross-platform.
Install: C<cpanm IO::Async::Loop::UV UV>

=back

=cut

my %opts = (
    host    => '127.0.0.1',
    port    => 5000,
    workers => 1,
);

GetOptions(
    'app|a=s'       => \$opts{app},
    'host|h=s'      => \$opts{host},
    'port|p=i'      => \$opts{port},
    'workers|w=i'   => \$opts{workers},
    'loop|l=s'      => \$opts{loop},
    'ssl-cert=s'    => \$opts{ssl_cert},
    'ssl-key=s'     => \$opts{ssl_key},
    'access-log=s'  => \$opts{access_log},
    'quiet|q'       => \$opts{quiet},
    'help'          => \$opts{help},
) or pod2usage(2);

pod2usage(1) if $opts{help};
pod2usage("--app is required") unless $opts{app};

# Validate app file exists
die "App file not found: $opts{app}\n" unless -f $opts{app};

# Validate SSL options
if ($opts{ssl_cert} || $opts{ssl_key}) {
    die "--ssl-cert and --ssl-key must be specified together\n"
        unless $opts{ssl_cert} && $opts{ssl_key};
    die "SSL cert not found: $opts{ssl_cert}\n" unless -f $opts{ssl_cert};
    die "SSL key not found: $opts{ssl_key}\n" unless -f $opts{ssl_key};
}

# Load the app - convert to absolute path for proper do() behavior
use File::Spec;
my $app_path = File::Spec->rel2abs($opts{app});
my $app = do $app_path;
die "Failed to load app: $@" if $@;
die "App file must return a coderef" unless ref $app eq 'CODE';

# Build server options
my %server_opts = (
    app     => $app,
    host    => $opts{host},
    port    => $opts{port},
    quiet   => $opts{quiet} ? 1 : 0,
    workers => $opts{workers} > 1 ? $opts{workers} : 0,  # 0 = single process mode
);

# Add SSL config if provided
if ($opts{ssl_cert} && $opts{ssl_key}) {
    $server_opts{ssl} = {
        cert_file => $opts{ssl_cert},
        key_file  => $opts{ssl_key},
    };
}

# Add access log if provided
if ($opts{access_log}) {
    open my $log_fh, '>>', $opts{access_log}
        or die "Cannot open access log $opts{access_log}: $!\n";
    $server_opts{access_log} = $log_fh;
}

# Create event loop (--loop option takes precedence over IO_ASYNC_LOOP env)
my $loop;
if ($opts{loop}) {
    my $loop_class = "IO::Async::Loop::$opts{loop}";
    eval "require $loop_class" or die "Error: Cannot load loop backend '$opts{loop}': $@\n" .
        "Install it with: cpanm $loop_class\n";
    $loop = $loop_class->new;
} else {
    $loop = IO::Async::Loop->new;
}

my $server = PAGI::Server->new(%server_opts);
$loop->add($server);

# Start listening with proper error handling
eval {
    $server->listen->get;
};
if ($@) {
    my $error = $@;
    # Clean up common IO::Async error messages
    if ($error =~ /Cannot bind\(\).*Address already in use/i) {
        die "Error: Port $opts{port} is already in use\n";
    }
    elsif ($error =~ /Cannot bind\(\).*Permission denied/i) {
        die "Error: Permission denied to bind to port $opts{port}\n";
    }
    elsif ($error =~ /Cannot bind\(\)/) {
        $error =~ s/\s+at\s+\S+\s+line\s+\d+.*//s;  # Strip stack trace
        die "Error: $error\n";
    }
    die "Error starting server: $error\n";
}

# Run the event loop
$loop->run;

__END__

=head1 AUTHOR

John Napiorkowski E<lt>jjnapiork@cpan.orgE<gt>

=head1 LICENSE

This software is licensed under the same terms as Perl itself.

=cut
